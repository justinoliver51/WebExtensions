package com.IBTrading.tradeparsers;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

public class ProfitlyTradeParser 
{
	// Passed parameters
	private String traderID;
	private String tradeString;
	
	// Parsed trade information
	public String symbol = null;
	public int quantity = 0;
	
	// Valid trade - true if parsed correctly, false otherwise
	public boolean isValidTrade = false;
	
	// PROFIT.LY
	// List of trader identifiers and their strings
	private String trader = null;  // Superman
	private static String lastTraderString;
	private static int tradePercentage = 0;
	
	private String SUPERMAN = "superman";  // Superman
	private static String supermanLastTraderString;
	private static int supermanTradePercentage = 25;
	
	private String SYKES = "sykes";  // Tim Sykes
	private static String sykesLastTraderString;
	private static int sykesTradePercentage = 25;
	
	
	
	
	
	public String date;
	public String action;
	public String totalQuant;
	public String symb;
	public String price;
	
	public ProfitlyTradeParser(String newTrade)
	{
		tradeString = newTrade;
	}
	
	public boolean parseTrade()
	{
		// If we are given an invalid value, return
		if(tradeString == null)
		{
			System.out.println("Null trade string");
			isValidTrade = false;
			return true;
		}
		
		// If we have already parsed this string, return
		if(tradeString.equalsIgnoreCase(lastTraderString))
		{
			System.out.println("Duplicate trade, " + tradeString);
			isValidTrade = false;
			return true;
		}
		
		// Get the useful information
		String[] tokens = tradeString.split("[ ]");
		int tokensIndex = 0;
		
		// Get the date
		date = tokens[tokensIndex++];
		
		// Ignore the time if it exists
		if( (tokens[tokensIndex].contains("AM")) || (tokens[tokensIndex].contains("PM")))
		{
			tokensIndex++;
		}
		else if( (tokens[tokensIndex + 1].contains("PM")) || (tokens[tokensIndex + 1].contains("PM")) )
		{
			tokensIndex = tokensIndex + 2;
		}
		
		// Get the action
		action = tokens[tokensIndex++];
		
		// Get the quantity
		totalQuant = tokens[tokensIndex];
		tokensIndex = tokensIndex + 2;
		
		// Get the symbol
		symb = tokens[tokensIndex];
		tokensIndex = tokensIndex + 2;
		
		// Get the price
		price = tokens[tokensIndex];
		
		isValidTrade = areParamatersValid(date, action, totalQuant, symb, price);
		
		// If everything went well, set up the trade
		if(isValidTrade == true)
		{
			// Update the globals
			symbol = symb;
			quantity = (Integer.parseInt(totalQuant) * tradePercentage) / 100;
			
			// Save this for next time
			supermanLastTraderString = tradeString;
		}
		else
			return false;
		
		return true;
	}
	
	public boolean areParamatersValid(String date, String action, String totalQuant, String symb, String price)
	{
		// Get the current date
		DateFormat dateFormatBought = new SimpleDateFormat("MM/dd");
		Date todaysDate = new Date();
		
		// If the date is not the current date
		if(date.equalsIgnoreCase(dateFormatBought.format(todaysDate)) == false)
		{
			System.out.println("Invalid date, " + date);
			return false;
		}
		
		// If the action is not 'Bought'
		if( (action.equalsIgnoreCase("Bought") == false) && (action.equalsIgnoreCase("Added") == false) )
		{
			System.out.println("Invalid action, " + action + " does not match 'Bought' or 'Added'...");
			return false;
		}
		
		// If the totalQuant is not a valid number > 0
		if(Integer.parseInt(totalQuant) <= 0)
		{
			System.out.println("Invalid quantity, " + quantity);
			return false;
		}
		
		// If the symbol is not valid
		if(symb.length() > 10)
		{
			System.out.println("Invalid symbol, " + symb);
			return false;
		}
		
		// If the price is unreasonable
		if(false)
		{
			return false;
		}
			
		// The parameters are valid
		return true;
	}
}
